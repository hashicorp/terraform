---
page_title: resource block reference
description: Learn how to configure the Terraform `resource` block.
---

# `resource` block

This topic provides reference information about the arguments Terraform natively supports in the `resource` block. Refer to the provider documentation for information about arguments specific to the providers you import 

## Introduction

Add `resource` blocks to your Terraform configuration to describe one or more infrastructure objects, such as virtual networks, compute instances, or higher-level components such as DNS records. Specific arguments that you can define in your configuration depend on the providers you import. 

Refer to the following topics for additional information:

- [usage topic about configuring the resource block]()
- [usage topic about configuring the provider block]()
- [provider block reference]()

## Configuration model

The following list provides an overview of the attributes you can declare in the `resource` block:

- [`resource "<TYPE>" "<LABEL>"`](#resource): block 
  - [`<PROVIDER_ARGUMENTS>`](#provider_arguments): arguments specific to the installed provider
  - [`count`](#resource-count): number 
  - [`depends_on`](#resource-depends_on): list or references
  - [`for_each`](#resource-for_each):  function
    - [`tomap()`](#resource-for_each): map of key-value pairs
    - [`toset()`](#resource-for_each): list of string values 
  - [`provider`](#resource-provider): reference
  - [`lifecycle`](#resource-lifecycle): block
    - [`create_before_destroy`](#resource-lifecycle-create_before_destroy): boolean
    - [`prevent_destroy`](#resource-lifecycle-prevent_destroy): boolean
    - [`ignore_changes`](#resource-lifecycle-ignore_changes): list of attribute names
    - [`replace_triggered_by`](#resource-lifecycle-replace_triggered_by): list of references
    - [`precondition`](#resource-lifecycle-precondition): block
    - [`postcondition`](#resource-lifecycle-postcondition): block
- [`provisioner "<TYPE>" "<LABEL>"`](#resource-provisioner): block 


## Specification

This section provides details about the arguments you can configure in the `resource` block. Specific providers and backends may support additional fields.

### `resource`

The main `resource` block accepts the following attributes:

- `TYPE` : Specifies the type of resource you can declare depends on the provider you import. Refer to the documentation for your provider for details. You can also specify the `terraform_data` resource type to implement a standard resource lifecycle. Refer to [Implement the standard resource lifecycle](linky-link) for additional information
- `LABEL`: Specifies an arbitrary name for the resource that you can use to reference the resource from other configuration elements. Refer to [Resource naming](/terraform/language/style#resource-naming) in the style guide for label recommendations.

### `PROVIDER_ARGUMENTS`

Specific arguments that you can define in your configuration depend on the providers you import. Refer to the documentation for your provider for details.  

- Data type: Determined by provider
- Default: None

### `resource{}.count`

Instructs Terraform to provision the specified number of identical resources. Use this argument to create a pool of distinct resource objects that have the same configuration. 

You cannot specify references to resource attributes, such as a unique ID generated by the cloud provider when it creates the object. Instead, specify a whole number value that Terraform can provide to the cloud provider prior to creating the resource so that the provider can create the specified number of instances. Refer to [Create multiple instances of a resource](#create-multiple-instances-of-a-resource) for an example.

The `count` argument exposes a `count` object that you can reference elsewhere in the configuration to modify specific instances. You can reference instances using the following format: `<TYPE>.<NAME>[INDEX]`. For example, `aws_instance.server[0]` refers to the first instance of the `aws_instance` resource named `server`.  Refer to [Usage topic about creating resources](linky-link) for additional information.

The `count` argument is a _meta-argument_, which refers to arguments that you can use in modules, as well as in any type of resource. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for additional information.

- Data type: Number. 
- Default: None. Terraform provisions a single instance by default.  

### `resource{}.depends_on`

Instructs Terraform to complete all actions on the specified object, including read actions, before performing actions associated with the resource. 

Terraform automatically infers dependencies, but adding the `depends_on` argument may be necessary when a resource depends on another object's behavior but does not have access to the data in the object arguments the resource depends on. Refer to [Specify a dependency](#specify-a-dependency) for an example configuration. 

Specifying an entire module in the `depends_on` argument affects the order in which Terraform processes all of the resources and data sources associated with that module. Refer to the following topics for additional information:

- [Resource dependencies](/terraform/language/manage-resources#resource-dependencies) 
- [Data resource dependencies](/terraform/language/configure-data-sources#data-resource-dependencies)

The `depends_on` argument is a _meta-argument_, which refers to arguments that you can use in modules, as well as in any type of resource. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for additional information.

- Data type: Reference. Refer to [References to Named Values](/terraform/reference/language/expressions/references) for syntax  
- Default: None. Terraform follows the dependency graph to determine dependencies. Refer to [internals](link) for additional information. 


### `resource{}.for_each`

Meta-argument that instructs Terraform to provision a set of similar resources that are the same type. The `for_each` argument accepts one of the following functions:

- `tomap()`: You can pass a map of key-value pairs to into the function. Terraform provisions a unique instance of the resource for each pair.  
- `toset()`: You can pass a list of strings to into the function. Terraform provisions a unique instance of the resource for string. The `for_each` argument does not implicitly convert lists or tubles to sets. 

- Reference expression: Terraform creates a resource for each item defined in the referenced object using the configurations specified in the resource block. Refer to [References to Named Values](/terraform/reference/language/expressions/references) for syntax.

Terraform must have a record of the keys, values in the list, or referenced objects in the `for_each` argument. Otherwise, Terraform prints an error message stating that the argument has dependencies that cannot be determined before the `terraform apply` command and that you may need to add a `-target` flag. 

Keys in the `for_each` argument keys cannot be derived from a functions because Terraform defers evaluation during the main evaluation step.

To declare resource instances based on a nested data structure or combinations of elements from multiple data structures you
can use Terraform expressions and functions to derive a suitable value. Refer to [Usage topic about creating resources](linky-link) for additional information.

The `for_each` argument exposes an `each` object that you can reference elsewhere in the configuration to modify specific instances. The `each` object has the following attributes:

-  `key`: Map or list member that corresponds to an instance.
- `value`: Map value that corresponds to an instance. 

Use the `<TYPE>.<NAME>[<KEY>]` format to reference an instance. For example, `azurerm_resource_group.rg["a_group"]` refers to an instance of the `azurrm_resource_group` resource named `a_group`.

The `for_each` argument is a _meta-argument_, which refers to arguments that you can use in modules, as well as in any type of resource. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for additional information.

- Data type: Function or reference expression. 
- Default: None. Terraform provisions a single instance by default. 

### `resource{}.provider`

Specifies a provider configuration for provisioning the resource. By default, Terraform automatically selects a provider based on the resource type, but you can create multiple provider configurations and select a specific configuration for the resources in the configuration. 

Use the `<PROVIDER>.<ALIAS>` format to reference a provider configuration in the `provider` argument. You must specify the `alias` argument in the `provider` block. Refer to [`provider` reference](/terraform/language/meta-arguments/provider) for details.   

Refer to [Select an alternate provider configuration](#select-an-alternate-provider-configuration) for an example.

The `provider` argument is a _meta-argument_, which refers to arguments that you can use in modules, as well as in any type of resource. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for additional information.

- Data type: Reference
- Default: None. Terraform automatically selects a provider based on the resource type by default. 

### `resource{}.lifecycle`

Meta-argument that specifies the infrastructure resource lifecycle. You can specify the following types of lifecycles:

- [`create_before_destroy`](#resource-lifecycle-create_before_destroy): Terraform creates a replacement object before destroying the previous object.
- [`prevent_destroy`](#resource-lifecycle-prevent_destroy): Terraform rejects operations that destroy infrastructure objects associated with the resource and returns an error.
- [`ignore_changes`](#resource-lifecycle-ignore_changes): Terraform ingores changes to the resource configuration. As a result, the remote resource under management remains unchanged.
- [`replace_triggered_by`](#resource-lifecycle-prevent-replace_triggered_by): Terraform replaces the resource when any of the specified items change.
- [`precondition`](#resource-lifecycle-precondition): Specifies an existing condition that triggers a check on the resource. Refer to [Create checks](linky-ti-link) for additional information.
- [`postcondition`](#resource-lifecycle-postcondition): Specifies a condition that emerges after a Terraform operation that triggers a check on the resource. Refer to [Create checks](linky-ti-link) for additional information.

Configurations defined in the `lifecycle` block affect how Terraform constructs and traverses the dependency graph. As a result, you can only use literal values because Terraform processes the configurations before it is able to evaluate arbitrary expressions.

The `lifecycle` block is a _meta-argument, which refers to arguments that you can use in modules, as well as in any type of resource. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for additional information.  

- Data type: Block.
- Default: Terraform applies the standard lifecycle. Refer to [Apply the standard lifecycle](#) for additional information.

### `resource{}.lifecycle{}.create_before_destroy`

Instructs Terraform to create a replacement resource before destroying the object it replaces. By default, Terraform destroys an object before creating a new instance to replace it. 

Refer to the documentation for the resource you are configuring before setting the `create_before_destroy` argument. The resource may have unique name requirements or other constraints that must be accommodated for both a new and an old object to exist concurrently. Some resource types offer special options to append a random suffix onto each object name to  avoid collisions, for example. The Terraform CLI cannot automatically activate these types of features.

Terraform propagates and applies the `create_before_destroy` behavior to all resource dependencies. For example, if `create_before_destroy` is enabled on resource A but not on resource B, but resource A is dependent on resource B, then Terraform enables `create_before_destroy` for resource B implicitly and stores it to the state file. You cannot override `create_before_destroy` to `false` on resource B because that would imply dependency cycles in the graph.

When `create_before_destroy` is set to `true`, a provisioner that would normally destroy the resource does not run. Refer to the GitHub issue titled ["on-destroy provisioners not being executed"](https://github.com/hashicorp/terraform/issues/13549) for details.

- Data type: Boolean
- Default: None. By default, Terraform destroys an object before creating its replacement.  

### `resource{}.lifecycle{}.prevent_destroy`

Instructs Terraform to reject any plan that would destroy the infrastructure object associated with the resource and print an error message. To destroy the resource, you must either remove it from the configuration or change the `prevent_destroy` argument to `false`. 

Use this argument to prevent team members from accidentally replacing an object that is costly to reproduce, such as database instances.

We recommend using this argument with caution because it makes some configuration changes impossible to apply and prevents you from using the `terraform destroy` command on the configuration.

- Data type: Boolean
- Default: None. 

### `resource{}.lifecycle{}.ignore_changes`

Specifies a list of resource attributes for Terraform to ignore when planning updates to the  associated remote object. Use this argument when the resource references data that may change but does not affect the resource after its creation.  

Terraform logs the specified arguments corresponding to the remote resource attribute names when planning a `create` operation, but it ignores the arguments when planning an `update` operation. You can specify arguments as the relative attribute addresses in the resource. You can specify members of maps and lists using index notation, such as `tags["Name"]` and `list[0]`. 

You can also specify the `all` instead of a list. The `all` keyword instructs Terraform to ignore all attributes. As a result, Terraform can create and destroy the remote object but it does not  propose updates to the object. 

Refer to [Ignore attribute changes](#ignore-attribute-changes) for an example.

- Data type: List of attributes.
- Default: None. By default, Terraform detects any difference in the current settings of a real infrastructure object and plans to update the remote object to match the configuration.

### `resource{}.lifecycle{}.replace_triggered_by`

Replaces the resource when any of the referenced items change. You can specify a list of expressions that reference managed resources, instances, or instance attributes. You can only reference managed resources in `replace_triggered_by` expressions. This lets you modify these expressions without forcing replacement.

Refer to [Specify triggers that replace resources](#specify-triggers-that-replace-resources) for an example configuration.

When added to a resource that uses `count` or `for_each`, you can use `count.index` or `each.key` in the expression to reference specific instances of other resources that are configured with the same count or collection.

This argument allows only resource addresses because the decision is based on the planned actions for all of the given resources. Plain values, such as local values or input variables, do not have planned actions of their own, but you can treat them with a resource-like lifecycle by using them with [the `terraform_data` resource type](/terraform/language/resources/terraform-data).

References trigger replacement in the following conditions:

- When the reference points to a resource with multiple instances, a plan to update or replace any instance triggers replacement.
- When the reference points to a single resource instance, a plan to update or  replace that instance triggers replacement.
- When the reference points to a single attribute of a resource instance, any change to the attribute value triggers replacement.

### `resource{}.lifecycle{}.precondition{}`

Specifies a condition that must return as `true` before Terraform evaluates the object associated  with the resource. You can also specify an error message for Terraform to print to the console when the condition returns `false`. Refer to [Create custom conditions](link to usage page) for information about adding validations to your Terraform configuration.

You can specify the following attributes in the `precondition` block:

| Attribute | Description | Data type |
| --- | --- | --- |
| `condition` | Expression that must return `true` for Terraform to proceed with an operation. You can refer to any other object in the same configuration scope unless the reference creates a cyclic dependency. | Expression that can include references, strings, and operators. |
| `error_message` | Message that Terraform prints to the console if the `condition` returns `false`. | String |

Terraform evaluates precondition blocks after evaluating existing `count` and `for_each` arguments. Doing so lets Terraform evaluate the `precondition` separately for each instance and then make the `each.key` and `count.index` objects  available in the conditions. 

Terraform evaluates `precondition` blocks before evaluating the resource's configuration arguments. The `precondition` can take precedence over argument evaluation errors.

You can include a `precondition` and [`postcondition` block](#resource-lifecycle-postcondition) in the same resource.

Do not add `precondition` blocks to a `resource` block and a `data` block that represent the same object in the same configuration. Doing so can prevent Terraform from understanding that the data block result can be affected by changes in the resource block. 

Refer to [Apply custom conditions](#apply-custom-conditions) for an example configuration.

### `resource{}.lifecycle{}.postcondition{}`

Specifies a condition that must return as `true` after Terraform evaluates the object associated with the resource. You can also specify an error message for Terraform to print to the console when the condition returns `false`. Refer to [Create custom conditions](link to usage page) for information about adding validations to your Terraform configuration.

You can specify the following attributes in the `precondition` block:

| Attribute | Description | Data type |
| --- | --- | --- |
| `condition` | Expression that must return `true` for Terraform to perform operations on downstream resources. You can refer to any other object in the same configuration scope unless the reference creates a cyclic dependency. | Expression that can include references, strings, and operators. |
| `error_message` | Message that Terraform prints to the console if the `condition` returns `false`. | String |

Terraform evaluates `postcondition` blocks after planning and applying changes to a managed resource. Postcondition failures prevent changes to other resources that depend on the failing resource.

You can include a `postcondition` and [`precondition` block](#resource-lifecycle-postcondition) in the same resource.

Do not add `postcondition` blocks to a `resource` block and a `data` block that represent the same object in the same configuration. Doing so can prevent Terraform from understanding that the data block result can be affected by changes in the resource block. 

Refer to [Apply custom conditions](#apply-custom-conditions) for an example configuration.


### `resource{}.provisioner{}`

A set of arguments that let you modle specific actions on the local or remote machine, such as preparing servers or other infrastructure objects for service. The `provisioner` argument has the following attributes:

- `TYPE`: Specifies one of the following provisioner types:
  - `file`: Copies files or directories form the machine where Terraform is running to the new resource.
  - `local-exec`: Invokes an executable on the local machine after Terraform creates the resource.
  - `remote-exec`: Invokes an executable on the remote resource after Terraform creates the resource.  
- `LABEL`: Optional attribute for adding a unique name. Refer to [Resource naming](/terraform/language/style#resource-naming) in the style guide for label recommendations.

Refer to the [`provisioner` block reference]() for additional information.

- Data type: Map
- Default: None

## Examples

The following examples describe common patterns for specific use cases.

### Define an AWS instance

The following example defines an `aws_instance` resource named `web`. 

resource "aws_instance" "web" {
  ami           = "ami-a1b2c3d4"
  instance_type = "t2.micro"
}

### Create multiple instances of a resource

You can use either the `count` or `for_each` block to create multiple instances of a resource. The `count` argument is most suitable for creating multiple instances that are identical or nearly identical. The `for_each` argument is most suitable for creating multiple instances that you can reference by name instead of index number to provide distinct values.

<Tabs>

<Tab heading="count">

The following example creates one instance for each subnet:

```
variable "subnet_ids" {
  type = list(string)
}

resource "aws_instance" "server" {

  count = length(var.subnet_ids)

  ami           = "ami-a1b2c3d4"
  instance_type = "t2.micro"
  subnet_id     = var.subnet_ids[count.index]

  tags = {
    Name = "Server ${count.index}"
  }
}

```
</Tab>

<Tab heading="for_each">

The following example creates two instances using the `tomap()` function:

```hcl
resource "azurerm_resource_group" "rg" {
  for_each = tomap({
    a_group       = "eastus"
    another_group = "westus2"
  })
  name     = each.key
  location = each.value
}

```

The following example creates four instances using the `toset()` function:

```hcl
resource "aws_iam_user" "the-accounts" {
  for_each = toset(["Todd", "James", "Alice", "Dottie"])
  name     = each.key
}

```

In the following example, Terraform creates two AWS S3 buckets using a child module defined in `my_buckets.tf`.  The `variable "name" {}` configuration defines the module's input parameter. Because `var.name` includes `each.key` when Terraform calls the module to provision an instance, the value changes for each instance.


<CodeBlockConfig filename="my_buckets.tf">

```hcl
module "bucket" {
  for_each = toset(["assets", "media"])
  source   = "./publish_bucket"
  name     = "${each.key}_bucket"
}
```

</CodeBlockConfig>


<CodeBlockConfig filename="publish_bucket/bucket-and-cloudfront.tf">

```hcl
variable "name" {}

resource "aws_s3_bucket" "example" {
  bucket = var.name
  ...
}

resource "aws_iam_user" "deploy_user" {
  ...
}
``` 

</CodeBlockConfig>

</Tab>

</Tabs>

### Specify a dependency

You can use the `depends_on` meta-argument in `module` blocks and in all `resource` blocks, regardless of resource type. It requires a list of references to other resources or child modules in the same calling module. This list cannot include arbitrary expressions because the `depends_on` value must be known before Terraform knows resource relationships and thus before it can safely evaluate expressions.

We recommend always including a comment that explains why using `depends_on` is necessary. The following example uses `depends_on` to handle a "hidden" dependency on the `aws_iam_instance_profile.example`.

```hcl
resource "aws_iam_role" "example" {
  name = "example"

  # assume_role_policy is omitted for brevity in this example. Refer to the
  # documentation for aws_iam_role for a complete example.
  assume_role_policy = "..."
}

resource "aws_iam_instance_profile" "example" {
  # Because this expression refers to the role, Terraform can infer
  # automatically that the role must be created first.
  role = aws_iam_role.example.name
}

resource "aws_iam_role_policy" "example" {
  name   = "example"
  role   = aws_iam_role.example.name
  policy = jsonencode({
    "Statement" = [{
      # This policy allows software running on the EC2 instance to
      # access the S3 API.
      "Action" = "s3:*",
      "Effect" = "Allow",
    }],
  })
}

resource "aws_instance" "example" {
  ami           = "ami-a1b2c3d4"
  instance_type = "t2.micro"

  # Terraform can infer from this that the instance profile must
  # be created before the EC2 instance.
  iam_instance_profile = aws_iam_instance_profile.example

  # However, if software running in this EC2 instance needs access
  # to the S3 API in order to boot properly, there is also a "hidden"
  # dependency on the aws_iam_role_policy that Terraform cannot
  # automatically infer, so it must be declared explicitly:
  depends_on = [
    aws_iam_role_policy.example
  ]
}
```

### Select an alternate provider configuration

In the following example, the `google_compute_instance` resource selects the provider configuration with the `europe` alias. 

```hcl
# default configuration
provider "google" {
  region = "us-central1"
}

# alternate configuration, whose alias is "europe"
provider "google" {
  alias  = "europe"
  region = "europe-west1"
}

resource "google_compute_instance" "example" {  
  provider = google.europe

  # ...
}
```

### Ignore attribute changes

In the following example, Terraform ignores changes to tags attached to the resource:

  ```hcl
  resource "aws_instance" "example" {
    # ...

    lifecycle {
      ignore_changes = [
        tags
      ]
    }
  }
  ```

### Specify triggers that replace resources

In the following example, Terraform replaces `aws_appautoscaling_target` each time this instance of `aws_ecs_service` is replaced:

 ```hcl
  resource "aws_appautoscaling_target" "ecs_target" {
    ...
    lifecycle {
      replace_triggered_by = [
        aws_ecs_service.svc.id
      ]
    }
  }
  ```

### Apply custom conditions

The following example shows use cases for preconditions and postconditions. The preconditions and postconditions declare the following assumptions and guarantees.

The AMI ID must refer to an AMI that contains an operating system for the x86_64 architecture. The precondition would detect if the caller accidentally built an AMI for a different architecture, which may not be able to run the software this virtual machine is intended to host.

The EC2 instance must be allocated a public DNS hostname. In Amazon Web Services, EC2 instances are assigned public DNS hostnames only if they belong to a virtual network configured in a certain way. The postcondition would detect if the selected virtual network is not configured correctly, prompting the user to debug the network settings.

The EC2 instance will have an encrypted root volume. The postcondition ensures that the root volume is encrypted, even though the software running in this EC2 instance would probably still operate as expected on an unencrypted volume. This lets Terraform produce an error immediately, before any other components rely on the new EC2 instance.

```hcl
data "aws_ami" "example" {
  owners = ["amazon"]

  filter {
    name   = "image-id"
    values = ["ami-abc123"]
  }
}

resource "aws_instance" "example" {
  instance_type = "t3.micro"
  ami           = data.aws_ami.example.id

  lifecycle {
    # The AMI ID must refer to an AMI that contains an operating system
    # for the `x86_64` architecture.
    precondition {
      condition     = data.aws_ami.example.architecture == "x86_64"
      error_message = "The selected AMI must be for the x86_64 architecture."
    }

    # The EC2 instance must be allocated a public DNS hostname.
    postcondition {
      condition     = self.public_dns != ""
      error_message = "EC2 instance must be in a VPC that has public DNS hostnames enabled."
    }
  }
}

data "aws_ebs_volume" "example" {
  # Use data resources that refer to other resources to
  # load extra data that isn't directly exported by a resource.
  #
  # Read the details about the root storage volume for the EC2 instance
  # declared by aws_instance.example, using the exported ID.

  filter {
    name = "volume-id"
    values = [aws_instance.example.root_block_device[0].volume_id]
  }

  # Whenever a data resource is verifying the result of a managed resource
  # declared in the same configuration, you MUST write the checks as
  # postconditions of the data resource. This ensures Terraform will wait
  # to read the data resource until after any changes to the managed resource
  # have completed.
  lifecycle {
    # The EC2 instance will have an encrypted root volume.
    postcondition {
      condition     = self.encrypted
      error_message = "The server's root volume is not encrypted."
    }
  }
}

output "api_base_url" {
  value = "https://${aws_instance.example.private_dns}:8433/"
}

```