---
page_title: Tests - Provider Mocking
description: >-
  Provide mocked data for providers and resources within `terraform test`.
---

# Mocks

-> **Note:** Mocked providers and the associated syntax are available in Terraform v1.7.0 and later.

Prior to Terraform v1.7.0, Terraform test authors were required to initialize and configure real Terraform providers for their tests. The `command = plan` setting could be used to avoid creating real infrastructure, but providers were still required to be correctly configured with the appropriate credentials and cloud accounts.

In Terraform v1.7.0, we launched support for mocking providers and modules, along with resources and data sources, within the Terraform test framework. Test authors can now use mock (or fake) providers, and their associated resources within their tests, requiring no credentials or associated accounts to exist. Within the context of `terraform test`, a mocked provider or resource will generate fake data for all computed attributes that would normally be provided by the underlying provider APIs.

Mocking functionality can only be used within the context of the [`terraform test` language](/terraform/language/tests). Readers of the mocking documentation should be aware of the surrounding testing syntax and language features.

In addition, the more advanced features of the mocking framework require knowledge about the following Terraform provider features:

- The difference between [attributes, nested attributes,](/terraform/plugin/framework/handling-data/attributes) and [blocks](https://developer.hashicorp.com/terraform/plugin/framework/handling-data/blocks).
- Definitions of [optional, required, and computed attributes](/terraform/plugin/framework/handling-data/attributes/string#configurability).


## Mock Providers

Within Terraform test files, you can use a new block type: `mock_provider`.

Mock providers return the same schema as the original provider and can be passed into your configuration under test in place of the matching provider. All resources and data sources retrieved by a mock provider will set the relevant values from the configuration, and generate fake data for any computed attributes.

Mock providers can be used directly in place of traditional `provider` blocks, and they share the same global namespace. During the execution of the `terraform test` command, Terraform does not distinguish between a real and a mocked provider.

The following example demonstrates a configuration that creates an AWS S3 bucket, and then uses a mocked provider in order to test the configuration without requiring an AWS account.

```hcl
# main.tf

terraform {
  required_providers {
    aws = {
        source = "hashicorp/aws"
    }
  }
}

variable "bucket_name" {
    type = string
}

resource "aws_s3_bucket" "my_bucket" {
    bucket = var.bucket_name
}
```

```hcl
# bucket_name.tftest.hcl

mock_provider "aws" {}

run "sets_correct_name" {
  variables {
    bucket_name = "my_bucket_name"
  }

  assert {
    condition     = aws_s3_bucket.my_bucket.bucket == "my_bucket_name"
    error_message = "incorrect bucket name"
  }
}
```

The above example validates the configuration is setting the correct bucket name on the AWS S3 bucket, and we can execute the test without provisioning an AWS account and accessing credentials first.

From the perspective of any `plan` or `apply` operations executed within a Terraform test file, the mocked provider is creating actual resources with values that match the configuration. These resources are stored within the Terraform state files that `terraform test` creates and holds in memory during test executions.

We can also interleave mocked providers and real providers within a Terraform test. In the following example we define two AWS providers, one real and one mocked. We must provide an alias to one of them, as they share the same global `aws` provider namespace. We can then use the `providers` attribute within test run blocks to customize which AWS provider is used for each run block. This behavior is the same as if we had defined two real providers, or two mocked providers, highlighting that Terraform considers mocked providers and real providers to be providers for the same set of resources.

```hcl
# mocked_providers.tftest.hcl

provider "aws" {}

mock_provider "aws" {
  alias = fake
}

run "use_real_provider" {
  providers = {
    aws = aws
  }
}

run "use_mocked_provider" {
  providers = {
    aws = aws.fake
  }
}
```

### Generated data

A mocked provider will generate data for any computed attributes within referenced data sources or attributes. For example, the `arn` attribute is a unique identifier generated by AWS for most resources. A mocked `aws` provider will provide a value for this attribute in any resources it creates.

> **Note**: Mocked providers do not have any information about the expected format of the computed attributes, so the generated data will rarely match any expected syntax that real providers would return for those attributes.

The generated data depends on the type of the underlying attributes:

- Numbers will be 0.
- Booleans will be false.
- Strings will be a random 8 character alphanumeric string.
- Collections, including sets, lists, and maps, will be empty collections.
- Objects will contain all required sub-attributes generated using this same set of rules recursively.

The above rules are consistent regardless of the type of the mocked provider, so a mocked `aws` and a mocked `google` provider apply the same rules when generating data.

Mocked providers only generate data for **computed** attributes. All required resource attributes must be set when using a mocked provider, as when using a real provider. Any optional and computed attributes will only be generated if the configuration does not already contain a value for them. An example of this is the `bucket` attribute in the `aws_s3_bucket` resource. A real AWS provider will generate a bucket name if one is not specified. A mocked AWS provider will do the same, and only generate a value if one is not already specified within the configuration.

### Mock Provider data

The automatically generated data, while useful for general consumption of mocked providers, may not match data required for a specific test. You can specify specific values you want to return for targeted resources and data sources.

Within a `mock_provider` block, you can write any number of `mock_resource` and `mock_data` blocks. Both accept a type argument that should match the resource or data source you want to provide values for. Both nested blocks accept a `defaults` object attribute, in which you can specify the values that should be returned for specific attributes.

The following example demonstrates providing a set `arn` value for all AWS S3 bucket resources and data sources:

```hcl
mock_provider "aws" {
  mock_resource "aws_s3_bucket" {
    defaults = {
      arn = "arn:aws:s3:::name"
    }
  }

  mock_data "aws_s3_bucket" {
    defaults = {
      arn = "arn:aws:s3:::name"
    }
  }
}
```

Now, Terraform will use the supplied value for `arn` attributes within S3 buckets instead of following the generated data rules and creating a random 8 character alphanumeric string. Computed attributes not provided an explicit default will simply fall back to the generic data generation rules.

You can also share mock provider data between tests by writing dedicated mock data files, and using the `source` attribute within the `mock_provider` block. Mock data files have `.tfmock.hcl` or `.tfmock.json` extensions, and can contain `mock_resource` and `mock_data` blocks as if they were defined within the `mock_provider` block directly.

```hcl
# ./testing/aws/data.tfmock.hcl

mock_resource "aws_s3_bucket" {
  defaults = {
    arn = "arn:aws:s3:::name"
  }
}

mock_data "aws_s3_bucket" {
  defaults = {
    arn = "arn:aws:s3:::name"
  }
}
```

```hcl
mock_provider "aws" {
  source = "./testing/aws"
}
```

In the above example, the `mock_resource` and `mock_data` blocks are defined within a mock data file within the relative directory `./testing/aws`. Multiple test files can then load and share the same mock provider data without copying the same definitions across all files.

You can combine the `source` attribute with directly nested `mock_resource` and `mock_data` blocks. If the source location and a directly nested block describe the same resource or data source then the directly nested block takes precedence.

## Overrides

In addition to mocking entire providers, you can override specific resources, data sources, and modules.

Terraform v1.7.0 introduced three new block types within Terraform test files:

- `override_resource`: Override the values of a specific resource. The underlying provider will not be consulted for the overridden resource.
- `override_data`: Override the values of a specific data source. The underlying provider will not be consulted for the overridden data source.
- `override_module`: Override the outputs of a specific module call. Any resources within the module will not be created, and the specified outputs will be returned instead.

The `override_module` block can be placed at the root level of Terraform test files and within Terraform test file run blocks.

The `override_resource` and `override_data` blocks can also be placed at the root level of Terraform test files and within Terraform test file run blocks. In addition, they can be nested within `mock_provider` blocks and within Terraform mock data files.

Overrides can be used alongside both real and mocked providers. In both cases, the override provides the computed values instead of the underlying provider.

### Overrides Syntax

All override blocks contain a `target` attribute, which should specify the resource, data source, or module that should be overridden. The `override_module` blocks then contain an `outputs` attribute, while the `override_resource` and `override_data` blocks contain a `values` attribute.

As with the `defaults` attribute in the `mock_resource` and `mock_data` blocks, the `outputs` and `values` attributes are optional and any outputs or computed attributes not specified will be generated by the testing framework.

The following example demonstrates using the override blocks at various different scopes and levels. There is a module that reads a file from an S3 bucket, and then the root configuration creates a local file that contains the data read from S3.

```hcl
# main.tf

terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
    }
  }
}

module "credentials" {
  source = "./modules/s3_data"

  data_bucket_name = "my_company_bucket_name"
}

resource "local_file" "credentials_json" {
  filename = "credentials.json"
  content = jsonencode(module.credentials.data)
}
```

```hcl
# ./modules/s3_data/main.tf

variable "data_bucket_name" {
  type = string
}

data "aws_s3_object" "data_bucket" {
  bucket = var.data_bucket_name
  key = "credentials.json"
}

output "data" {
  value = jsondecode(data.aws_s3_object.data_bucket.body)
}
```

Firstly, the `aws_s3_bucket_object` within the module could be overridden directly within a mock provider. There is an `override_data` block within the `mock_provider` block, this means that the target data source will only be overridden if it is loaded by that specific mock provider.

```hcl
# main.tftest.hcl

mock_provider "aws" {
  override_data {
    target = module.credentials.data.aws_s3_object.data_bucket
    values = {
      body = "{\"username\":\"username\",\"password\":\"password\"}"
    }
  }
}

run "test" {
  assert {
    condition     = jsondecode(local_file.credentials_json.content).username == "username"
    error_message = "incorrect username"
  }
}
```

Alternatively, the same `aws_s3_bucket_object` could be overridden within the test file itself, or within a run block. In this case, the underlying provider doesn't matter as the data source at the target address is overridden regardless of the provider. The example still mocks the provider so this can be run without AWS credentials. Override blocks can override resources provided by real providers.

```hcl
# main.tftest.hcl

mock_provider "aws" {}

override_data {
  target = module.credentials.data.aws_s3_object.data_bucket
  values = {
    body = "{\"username\":\"username\",\"password\":\"password\"}"
  }
}

run "test_file_override" {
  assert {
    condition     = jsondecode(local_file.credentials_json.content).username == "username"
    error_message = "incorrect username"
  }
}

run "test_run_override" {
  # The value within this local override block takes precedence over the
  # alternate defined within the file.
  override_data {
    target = module.credentials.data.aws_s3_object.data_bucket
    values = {
      body = "{\"username\":\"a_different_username\",\"password\":\"password\"}"
    }
  }

  assert {
    condition     = jsondecode(local_file.credentials_json.content).username == "a_different_username"
    error_message = "incorrect username"
  }
}
```

In the above example, the override block defined at the file level is used within the first run block. Then in the second run block, the alternative local override takes precedence over the file level override. File level overrides and run block overrides both take precedence over overrides defined within mock providers.

Finally, the entire module can be overridden:

```hcl
# main.tftest.hcl
mock_provider "aws" {}

override_module {
  target = module.credentials
  outputs = {
    data = { username = "username", password = "password" }
  }
}

run "test" {
  assert {
    condition     = jsondecode(local_file.credentials_json.content).username == "username"
    error_message = "incorrect username"
  }
}
```

In the above example, the module is overridden in the entirety instead of the specific resources within the module. In this case, the override block is specifying `outputs` instead of `values` and the output value is specified as HCL instead of as a string as the real module is passing the data through the `jsondecode` function. As with `override_data` blocks, the `override_module` block could be specified within the run block and the same precedence rules apply.

The `override_resource` blocks match the behaviour of the `override_data` blocks.

## Repeated blocks and nested attributes

The examples within this page have so far focused on generating values for simple attributes. Some resources and data sources specify repeated nested attributes as computed directly, while repeated blocks within the resource may also contain computed attributes.

For repeated blocks and nested attributes, you cannot specify values for specific instances within the collection. Instead, you provide a single set of values that apply for all instances within the collection.

As an example, consider the `aws_dynamodb_table` resource. It contains a root level computed `arn` attribute, and a set-repeated block called `replica` which also contains a computed `arn` attribute. A typical configuration might look like this:

```hcl
# main.tf

resource "aws_dynamodb_table" "my_table" {
  name     = "my_table"
  hash_key = "key"

  attribute {
    name = "key"
    type = "S"
  }

  replica {
    region_name = "eu-west-2"
  }

  replica {
    region_name = "us-east-1"
  }
}
```

In normal execution, the AWS provider would return ARN values for the main DynamoDB table and for both the specified replicas. While a `mock_resource` block can mimic this behavior, it cannot differentiate between the multiple `replica` blocks within the resource:

```hcl
mock_resource "aws_dynamodb_table" {
  defaults = {
    arn     = "aws:dynamodb:::my_table"
    replica = {
      arn = "aws:dynamodb:::my_replica"
    }
  }
}
```

In this case, the `mock_resource` provides a specific value for the ARN returned for the main table, but the ARN values returned for the replica tables are shared between all instances. It is not currently possible to specify values for specific instances within repeated blocks during `terraform test` executions.

The reason for this behaviour is that it is not possible for Terraform to match repeated blocks in a set between the configuration and the specified values from the mock or override block. Terraform has no way to resolve which instance within the values should apply to which instance within the configuration, so a single instance must apply to all values within the collection.
