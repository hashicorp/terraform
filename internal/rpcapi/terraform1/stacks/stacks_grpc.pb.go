// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.15.6
// source: stacks.proto

package stacks

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Stacks_OpenStackConfiguration_FullMethodName           = "/terraform1.stacks.Stacks/OpenStackConfiguration"
	Stacks_CloseStackConfiguration_FullMethodName          = "/terraform1.stacks.Stacks/CloseStackConfiguration"
	Stacks_ValidateStackConfiguration_FullMethodName       = "/terraform1.stacks.Stacks/ValidateStackConfiguration"
	Stacks_FindStackConfigurationComponents_FullMethodName = "/terraform1.stacks.Stacks/FindStackConfigurationComponents"
	Stacks_OpenState_FullMethodName                        = "/terraform1.stacks.Stacks/OpenState"
	Stacks_CloseState_FullMethodName                       = "/terraform1.stacks.Stacks/CloseState"
	Stacks_PlanStackChanges_FullMethodName                 = "/terraform1.stacks.Stacks/PlanStackChanges"
	Stacks_OpenPlan_FullMethodName                         = "/terraform1.stacks.Stacks/OpenPlan"
	Stacks_ClosePlan_FullMethodName                        = "/terraform1.stacks.Stacks/ClosePlan"
	Stacks_ApplyStackChanges_FullMethodName                = "/terraform1.stacks.Stacks/ApplyStackChanges"
	Stacks_OpenStackInspector_FullMethodName               = "/terraform1.stacks.Stacks/OpenStackInspector"
	Stacks_InspectExpressionResult_FullMethodName          = "/terraform1.stacks.Stacks/InspectExpressionResult"
	Stacks_OpenTerraformState_FullMethodName               = "/terraform1.stacks.Stacks/OpenTerraformState"
	Stacks_CloseTerraformState_FullMethodName              = "/terraform1.stacks.Stacks/CloseTerraformState"
	Stacks_MigrateTerraformState_FullMethodName            = "/terraform1.stacks.Stacks/MigrateTerraformState"
	Stacks_ListResourceIdentities_FullMethodName           = "/terraform1.stacks.Stacks/ListResourceIdentities"
)

// StacksClient is the client API for Stacks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StacksClient interface {
	// Load and perform initial static validation of a stack configuration
	// in a previously-opened source bundle. If successful, returns a
	// stack configuration handle that can be used with other operations.
	OpenStackConfiguration(ctx context.Context, in *OpenStackConfiguration_Request, opts ...grpc.CallOption) (*OpenStackConfiguration_Response, error)
	// Close a previously-opened stack configuration using its handle.
	CloseStackConfiguration(ctx context.Context, in *CloseStackConfiguration_Request, opts ...grpc.CallOption) (*CloseStackConfiguration_Response, error)
	// Validate an open stack configuration.
	ValidateStackConfiguration(ctx context.Context, in *ValidateStackConfiguration_Request, opts ...grpc.CallOption) (*ValidateStackConfiguration_Response, error)
	// Analyze a stack configuration to find all of the components it declares.
	// This is static analysis only, so it cannot produce dynamic information
	// such as the number of instances of each component.
	FindStackConfigurationComponents(ctx context.Context, in *FindStackConfigurationComponents_Request, opts ...grpc.CallOption) (*FindStackConfigurationComponents_Response, error)
	// Load a stack state by sending a stream of raw state objects that were
	// streamed from a previous ApplyStackChanges response.
	OpenState(ctx context.Context, opts ...grpc.CallOption) (Stacks_OpenStateClient, error)
	// Close a stack state handle, discarding the associated state.
	CloseState(ctx context.Context, in *CloseStackState_Request, opts ...grpc.CallOption) (*CloseStackState_Response, error)
	// Calculate a desired state from the given configuration and compare it
	// with the current state to propose a set of changes to converge the
	// current state with the desired state, at least in part.
	PlanStackChanges(ctx context.Context, in *PlanStackChanges_Request, opts ...grpc.CallOption) (Stacks_PlanStackChangesClient, error)
	// Load a previously-created plan by sending a stream of raw change objects
	// that were streamed from a previous PlanStackChanges response.
	OpenPlan(ctx context.Context, opts ...grpc.CallOption) (Stacks_OpenPlanClient, error)
	// Close a saved plan handle, discarding the associated saved plan.
	ClosePlan(ctx context.Context, in *CloseStackPlan_Request, opts ...grpc.CallOption) (*CloseStackPlan_Response, error)
	// Execute the changes proposed by an earlier call to PlanStackChanges.
	ApplyStackChanges(ctx context.Context, in *ApplyStackChanges_Request, opts ...grpc.CallOption) (Stacks_ApplyStackChangesClient, error)
	// OpenStackInspector creates a stack inspector handle that can be used
	// with subsequent calls to the "Inspect"-prefixed functions.
	OpenStackInspector(ctx context.Context, in *OpenStackInspector_Request, opts ...grpc.CallOption) (*OpenStackInspector_Response, error)
	// InspectExpressionResult evaluates an arbitrary expression in the context
	// of a stack inspector handle.
	InspectExpressionResult(ctx context.Context, in *InspectExpressionResult_Request, opts ...grpc.CallOption) (*InspectExpressionResult_Response, error)
	// Open a previously-saved Terraform state, returning a handle that can be
	// used with other operations. This is distinct from OpenState because it
	// means core state rather than stack state.
	OpenTerraformState(ctx context.Context, in *OpenTerraformState_Request, opts ...grpc.CallOption) (*OpenTerraformState_Response, error)
	// Close a previously-opened Terraform state using its handle.
	CloseTerraformState(ctx context.Context, in *CloseTerraformState_Request, opts ...grpc.CallOption) (*CloseTerraformState_Response, error)
	// MigrateTerraformState migrates a Terraform state into Stacks state using
	// a mapping of addresses.
	MigrateTerraformState(ctx context.Context, in *MigrateTerraformState_Request, opts ...grpc.CallOption) (Stacks_MigrateTerraformStateClient, error)
	// ListResourceIdentities lists the identities of all resources in a stack.
	ListResourceIdentities(ctx context.Context, in *ListResourceIdentities_Request, opts ...grpc.CallOption) (*ListResourceIdentities_Response, error)
}

type stacksClient struct {
	cc grpc.ClientConnInterface
}

func NewStacksClient(cc grpc.ClientConnInterface) StacksClient {
	return &stacksClient{cc}
}

func (c *stacksClient) OpenStackConfiguration(ctx context.Context, in *OpenStackConfiguration_Request, opts ...grpc.CallOption) (*OpenStackConfiguration_Response, error) {
	out := new(OpenStackConfiguration_Response)
	err := c.cc.Invoke(ctx, Stacks_OpenStackConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stacksClient) CloseStackConfiguration(ctx context.Context, in *CloseStackConfiguration_Request, opts ...grpc.CallOption) (*CloseStackConfiguration_Response, error) {
	out := new(CloseStackConfiguration_Response)
	err := c.cc.Invoke(ctx, Stacks_CloseStackConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stacksClient) ValidateStackConfiguration(ctx context.Context, in *ValidateStackConfiguration_Request, opts ...grpc.CallOption) (*ValidateStackConfiguration_Response, error) {
	out := new(ValidateStackConfiguration_Response)
	err := c.cc.Invoke(ctx, Stacks_ValidateStackConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stacksClient) FindStackConfigurationComponents(ctx context.Context, in *FindStackConfigurationComponents_Request, opts ...grpc.CallOption) (*FindStackConfigurationComponents_Response, error) {
	out := new(FindStackConfigurationComponents_Response)
	err := c.cc.Invoke(ctx, Stacks_FindStackConfigurationComponents_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stacksClient) OpenState(ctx context.Context, opts ...grpc.CallOption) (Stacks_OpenStateClient, error) {
	stream, err := c.cc.NewStream(ctx, &Stacks_ServiceDesc.Streams[0], Stacks_OpenState_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &stacksOpenStateClient{stream}
	return x, nil
}

type Stacks_OpenStateClient interface {
	Send(*OpenStackState_RequestItem) error
	CloseAndRecv() (*OpenStackState_Response, error)
	grpc.ClientStream
}

type stacksOpenStateClient struct {
	grpc.ClientStream
}

func (x *stacksOpenStateClient) Send(m *OpenStackState_RequestItem) error {
	return x.ClientStream.SendMsg(m)
}

func (x *stacksOpenStateClient) CloseAndRecv() (*OpenStackState_Response, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(OpenStackState_Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stacksClient) CloseState(ctx context.Context, in *CloseStackState_Request, opts ...grpc.CallOption) (*CloseStackState_Response, error) {
	out := new(CloseStackState_Response)
	err := c.cc.Invoke(ctx, Stacks_CloseState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stacksClient) PlanStackChanges(ctx context.Context, in *PlanStackChanges_Request, opts ...grpc.CallOption) (Stacks_PlanStackChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Stacks_ServiceDesc.Streams[1], Stacks_PlanStackChanges_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &stacksPlanStackChangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stacks_PlanStackChangesClient interface {
	Recv() (*PlanStackChanges_Event, error)
	grpc.ClientStream
}

type stacksPlanStackChangesClient struct {
	grpc.ClientStream
}

func (x *stacksPlanStackChangesClient) Recv() (*PlanStackChanges_Event, error) {
	m := new(PlanStackChanges_Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stacksClient) OpenPlan(ctx context.Context, opts ...grpc.CallOption) (Stacks_OpenPlanClient, error) {
	stream, err := c.cc.NewStream(ctx, &Stacks_ServiceDesc.Streams[2], Stacks_OpenPlan_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &stacksOpenPlanClient{stream}
	return x, nil
}

type Stacks_OpenPlanClient interface {
	Send(*OpenStackPlan_RequestItem) error
	CloseAndRecv() (*OpenStackPlan_Response, error)
	grpc.ClientStream
}

type stacksOpenPlanClient struct {
	grpc.ClientStream
}

func (x *stacksOpenPlanClient) Send(m *OpenStackPlan_RequestItem) error {
	return x.ClientStream.SendMsg(m)
}

func (x *stacksOpenPlanClient) CloseAndRecv() (*OpenStackPlan_Response, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(OpenStackPlan_Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stacksClient) ClosePlan(ctx context.Context, in *CloseStackPlan_Request, opts ...grpc.CallOption) (*CloseStackPlan_Response, error) {
	out := new(CloseStackPlan_Response)
	err := c.cc.Invoke(ctx, Stacks_ClosePlan_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stacksClient) ApplyStackChanges(ctx context.Context, in *ApplyStackChanges_Request, opts ...grpc.CallOption) (Stacks_ApplyStackChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Stacks_ServiceDesc.Streams[3], Stacks_ApplyStackChanges_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &stacksApplyStackChangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stacks_ApplyStackChangesClient interface {
	Recv() (*ApplyStackChanges_Event, error)
	grpc.ClientStream
}

type stacksApplyStackChangesClient struct {
	grpc.ClientStream
}

func (x *stacksApplyStackChangesClient) Recv() (*ApplyStackChanges_Event, error) {
	m := new(ApplyStackChanges_Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stacksClient) OpenStackInspector(ctx context.Context, in *OpenStackInspector_Request, opts ...grpc.CallOption) (*OpenStackInspector_Response, error) {
	out := new(OpenStackInspector_Response)
	err := c.cc.Invoke(ctx, Stacks_OpenStackInspector_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stacksClient) InspectExpressionResult(ctx context.Context, in *InspectExpressionResult_Request, opts ...grpc.CallOption) (*InspectExpressionResult_Response, error) {
	out := new(InspectExpressionResult_Response)
	err := c.cc.Invoke(ctx, Stacks_InspectExpressionResult_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stacksClient) OpenTerraformState(ctx context.Context, in *OpenTerraformState_Request, opts ...grpc.CallOption) (*OpenTerraformState_Response, error) {
	out := new(OpenTerraformState_Response)
	err := c.cc.Invoke(ctx, Stacks_OpenTerraformState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stacksClient) CloseTerraformState(ctx context.Context, in *CloseTerraformState_Request, opts ...grpc.CallOption) (*CloseTerraformState_Response, error) {
	out := new(CloseTerraformState_Response)
	err := c.cc.Invoke(ctx, Stacks_CloseTerraformState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stacksClient) MigrateTerraformState(ctx context.Context, in *MigrateTerraformState_Request, opts ...grpc.CallOption) (Stacks_MigrateTerraformStateClient, error) {
	stream, err := c.cc.NewStream(ctx, &Stacks_ServiceDesc.Streams[4], Stacks_MigrateTerraformState_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &stacksMigrateTerraformStateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stacks_MigrateTerraformStateClient interface {
	Recv() (*MigrateTerraformState_Event, error)
	grpc.ClientStream
}

type stacksMigrateTerraformStateClient struct {
	grpc.ClientStream
}

func (x *stacksMigrateTerraformStateClient) Recv() (*MigrateTerraformState_Event, error) {
	m := new(MigrateTerraformState_Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stacksClient) ListResourceIdentities(ctx context.Context, in *ListResourceIdentities_Request, opts ...grpc.CallOption) (*ListResourceIdentities_Response, error) {
	out := new(ListResourceIdentities_Response)
	err := c.cc.Invoke(ctx, Stacks_ListResourceIdentities_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StacksServer is the server API for Stacks service.
// All implementations should embed UnimplementedStacksServer
// for forward compatibility
type StacksServer interface {
	// Load and perform initial static validation of a stack configuration
	// in a previously-opened source bundle. If successful, returns a
	// stack configuration handle that can be used with other operations.
	OpenStackConfiguration(context.Context, *OpenStackConfiguration_Request) (*OpenStackConfiguration_Response, error)
	// Close a previously-opened stack configuration using its handle.
	CloseStackConfiguration(context.Context, *CloseStackConfiguration_Request) (*CloseStackConfiguration_Response, error)
	// Validate an open stack configuration.
	ValidateStackConfiguration(context.Context, *ValidateStackConfiguration_Request) (*ValidateStackConfiguration_Response, error)
	// Analyze a stack configuration to find all of the components it declares.
	// This is static analysis only, so it cannot produce dynamic information
	// such as the number of instances of each component.
	FindStackConfigurationComponents(context.Context, *FindStackConfigurationComponents_Request) (*FindStackConfigurationComponents_Response, error)
	// Load a stack state by sending a stream of raw state objects that were
	// streamed from a previous ApplyStackChanges response.
	OpenState(Stacks_OpenStateServer) error
	// Close a stack state handle, discarding the associated state.
	CloseState(context.Context, *CloseStackState_Request) (*CloseStackState_Response, error)
	// Calculate a desired state from the given configuration and compare it
	// with the current state to propose a set of changes to converge the
	// current state with the desired state, at least in part.
	PlanStackChanges(*PlanStackChanges_Request, Stacks_PlanStackChangesServer) error
	// Load a previously-created plan by sending a stream of raw change objects
	// that were streamed from a previous PlanStackChanges response.
	OpenPlan(Stacks_OpenPlanServer) error
	// Close a saved plan handle, discarding the associated saved plan.
	ClosePlan(context.Context, *CloseStackPlan_Request) (*CloseStackPlan_Response, error)
	// Execute the changes proposed by an earlier call to PlanStackChanges.
	ApplyStackChanges(*ApplyStackChanges_Request, Stacks_ApplyStackChangesServer) error
	// OpenStackInspector creates a stack inspector handle that can be used
	// with subsequent calls to the "Inspect"-prefixed functions.
	OpenStackInspector(context.Context, *OpenStackInspector_Request) (*OpenStackInspector_Response, error)
	// InspectExpressionResult evaluates an arbitrary expression in the context
	// of a stack inspector handle.
	InspectExpressionResult(context.Context, *InspectExpressionResult_Request) (*InspectExpressionResult_Response, error)
	// Open a previously-saved Terraform state, returning a handle that can be
	// used with other operations. This is distinct from OpenState because it
	// means core state rather than stack state.
	OpenTerraformState(context.Context, *OpenTerraformState_Request) (*OpenTerraformState_Response, error)
	// Close a previously-opened Terraform state using its handle.
	CloseTerraformState(context.Context, *CloseTerraformState_Request) (*CloseTerraformState_Response, error)
	// MigrateTerraformState migrates a Terraform state into Stacks state using
	// a mapping of addresses.
	MigrateTerraformState(*MigrateTerraformState_Request, Stacks_MigrateTerraformStateServer) error
	// ListResourceIdentities lists the identities of all resources in a stack.
	ListResourceIdentities(context.Context, *ListResourceIdentities_Request) (*ListResourceIdentities_Response, error)
}

// UnimplementedStacksServer should be embedded to have forward compatible implementations.
type UnimplementedStacksServer struct {
}

func (UnimplementedStacksServer) OpenStackConfiguration(context.Context, *OpenStackConfiguration_Request) (*OpenStackConfiguration_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenStackConfiguration not implemented")
}
func (UnimplementedStacksServer) CloseStackConfiguration(context.Context, *CloseStackConfiguration_Request) (*CloseStackConfiguration_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseStackConfiguration not implemented")
}
func (UnimplementedStacksServer) ValidateStackConfiguration(context.Context, *ValidateStackConfiguration_Request) (*ValidateStackConfiguration_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateStackConfiguration not implemented")
}
func (UnimplementedStacksServer) FindStackConfigurationComponents(context.Context, *FindStackConfigurationComponents_Request) (*FindStackConfigurationComponents_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindStackConfigurationComponents not implemented")
}
func (UnimplementedStacksServer) OpenState(Stacks_OpenStateServer) error {
	return status.Errorf(codes.Unimplemented, "method OpenState not implemented")
}
func (UnimplementedStacksServer) CloseState(context.Context, *CloseStackState_Request) (*CloseStackState_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseState not implemented")
}
func (UnimplementedStacksServer) PlanStackChanges(*PlanStackChanges_Request, Stacks_PlanStackChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method PlanStackChanges not implemented")
}
func (UnimplementedStacksServer) OpenPlan(Stacks_OpenPlanServer) error {
	return status.Errorf(codes.Unimplemented, "method OpenPlan not implemented")
}
func (UnimplementedStacksServer) ClosePlan(context.Context, *CloseStackPlan_Request) (*CloseStackPlan_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClosePlan not implemented")
}
func (UnimplementedStacksServer) ApplyStackChanges(*ApplyStackChanges_Request, Stacks_ApplyStackChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method ApplyStackChanges not implemented")
}
func (UnimplementedStacksServer) OpenStackInspector(context.Context, *OpenStackInspector_Request) (*OpenStackInspector_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenStackInspector not implemented")
}
func (UnimplementedStacksServer) InspectExpressionResult(context.Context, *InspectExpressionResult_Request) (*InspectExpressionResult_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectExpressionResult not implemented")
}
func (UnimplementedStacksServer) OpenTerraformState(context.Context, *OpenTerraformState_Request) (*OpenTerraformState_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenTerraformState not implemented")
}
func (UnimplementedStacksServer) CloseTerraformState(context.Context, *CloseTerraformState_Request) (*CloseTerraformState_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseTerraformState not implemented")
}
func (UnimplementedStacksServer) MigrateTerraformState(*MigrateTerraformState_Request, Stacks_MigrateTerraformStateServer) error {
	return status.Errorf(codes.Unimplemented, "method MigrateTerraformState not implemented")
}
func (UnimplementedStacksServer) ListResourceIdentities(context.Context, *ListResourceIdentities_Request) (*ListResourceIdentities_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListResourceIdentities not implemented")
}

// UnsafeStacksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StacksServer will
// result in compilation errors.
type UnsafeStacksServer interface {
	mustEmbedUnimplementedStacksServer()
}

func RegisterStacksServer(s grpc.ServiceRegistrar, srv StacksServer) {
	s.RegisterService(&Stacks_ServiceDesc, srv)
}

func _Stacks_OpenStackConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenStackConfiguration_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StacksServer).OpenStackConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stacks_OpenStackConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StacksServer).OpenStackConfiguration(ctx, req.(*OpenStackConfiguration_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stacks_CloseStackConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseStackConfiguration_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StacksServer).CloseStackConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stacks_CloseStackConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StacksServer).CloseStackConfiguration(ctx, req.(*CloseStackConfiguration_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stacks_ValidateStackConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateStackConfiguration_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StacksServer).ValidateStackConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stacks_ValidateStackConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StacksServer).ValidateStackConfiguration(ctx, req.(*ValidateStackConfiguration_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stacks_FindStackConfigurationComponents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindStackConfigurationComponents_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StacksServer).FindStackConfigurationComponents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stacks_FindStackConfigurationComponents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StacksServer).FindStackConfigurationComponents(ctx, req.(*FindStackConfigurationComponents_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stacks_OpenState_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StacksServer).OpenState(&stacksOpenStateServer{stream})
}

type Stacks_OpenStateServer interface {
	SendAndClose(*OpenStackState_Response) error
	Recv() (*OpenStackState_RequestItem, error)
	grpc.ServerStream
}

type stacksOpenStateServer struct {
	grpc.ServerStream
}

func (x *stacksOpenStateServer) SendAndClose(m *OpenStackState_Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *stacksOpenStateServer) Recv() (*OpenStackState_RequestItem, error) {
	m := new(OpenStackState_RequestItem)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Stacks_CloseState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseStackState_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StacksServer).CloseState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stacks_CloseState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StacksServer).CloseState(ctx, req.(*CloseStackState_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stacks_PlanStackChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PlanStackChanges_Request)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StacksServer).PlanStackChanges(m, &stacksPlanStackChangesServer{stream})
}

type Stacks_PlanStackChangesServer interface {
	Send(*PlanStackChanges_Event) error
	grpc.ServerStream
}

type stacksPlanStackChangesServer struct {
	grpc.ServerStream
}

func (x *stacksPlanStackChangesServer) Send(m *PlanStackChanges_Event) error {
	return x.ServerStream.SendMsg(m)
}

func _Stacks_OpenPlan_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StacksServer).OpenPlan(&stacksOpenPlanServer{stream})
}

type Stacks_OpenPlanServer interface {
	SendAndClose(*OpenStackPlan_Response) error
	Recv() (*OpenStackPlan_RequestItem, error)
	grpc.ServerStream
}

type stacksOpenPlanServer struct {
	grpc.ServerStream
}

func (x *stacksOpenPlanServer) SendAndClose(m *OpenStackPlan_Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *stacksOpenPlanServer) Recv() (*OpenStackPlan_RequestItem, error) {
	m := new(OpenStackPlan_RequestItem)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Stacks_ClosePlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseStackPlan_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StacksServer).ClosePlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stacks_ClosePlan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StacksServer).ClosePlan(ctx, req.(*CloseStackPlan_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stacks_ApplyStackChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ApplyStackChanges_Request)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StacksServer).ApplyStackChanges(m, &stacksApplyStackChangesServer{stream})
}

type Stacks_ApplyStackChangesServer interface {
	Send(*ApplyStackChanges_Event) error
	grpc.ServerStream
}

type stacksApplyStackChangesServer struct {
	grpc.ServerStream
}

func (x *stacksApplyStackChangesServer) Send(m *ApplyStackChanges_Event) error {
	return x.ServerStream.SendMsg(m)
}

func _Stacks_OpenStackInspector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenStackInspector_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StacksServer).OpenStackInspector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stacks_OpenStackInspector_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StacksServer).OpenStackInspector(ctx, req.(*OpenStackInspector_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stacks_InspectExpressionResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectExpressionResult_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StacksServer).InspectExpressionResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stacks_InspectExpressionResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StacksServer).InspectExpressionResult(ctx, req.(*InspectExpressionResult_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stacks_OpenTerraformState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenTerraformState_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StacksServer).OpenTerraformState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stacks_OpenTerraformState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StacksServer).OpenTerraformState(ctx, req.(*OpenTerraformState_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stacks_CloseTerraformState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseTerraformState_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StacksServer).CloseTerraformState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stacks_CloseTerraformState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StacksServer).CloseTerraformState(ctx, req.(*CloseTerraformState_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stacks_MigrateTerraformState_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MigrateTerraformState_Request)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StacksServer).MigrateTerraformState(m, &stacksMigrateTerraformStateServer{stream})
}

type Stacks_MigrateTerraformStateServer interface {
	Send(*MigrateTerraformState_Event) error
	grpc.ServerStream
}

type stacksMigrateTerraformStateServer struct {
	grpc.ServerStream
}

func (x *stacksMigrateTerraformStateServer) Send(m *MigrateTerraformState_Event) error {
	return x.ServerStream.SendMsg(m)
}

func _Stacks_ListResourceIdentities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListResourceIdentities_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StacksServer).ListResourceIdentities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stacks_ListResourceIdentities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StacksServer).ListResourceIdentities(ctx, req.(*ListResourceIdentities_Request))
	}
	return interceptor(ctx, in, info, handler)
}

// Stacks_ServiceDesc is the grpc.ServiceDesc for Stacks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Stacks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "terraform1.stacks.Stacks",
	HandlerType: (*StacksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OpenStackConfiguration",
			Handler:    _Stacks_OpenStackConfiguration_Handler,
		},
		{
			MethodName: "CloseStackConfiguration",
			Handler:    _Stacks_CloseStackConfiguration_Handler,
		},
		{
			MethodName: "ValidateStackConfiguration",
			Handler:    _Stacks_ValidateStackConfiguration_Handler,
		},
		{
			MethodName: "FindStackConfigurationComponents",
			Handler:    _Stacks_FindStackConfigurationComponents_Handler,
		},
		{
			MethodName: "CloseState",
			Handler:    _Stacks_CloseState_Handler,
		},
		{
			MethodName: "ClosePlan",
			Handler:    _Stacks_ClosePlan_Handler,
		},
		{
			MethodName: "OpenStackInspector",
			Handler:    _Stacks_OpenStackInspector_Handler,
		},
		{
			MethodName: "InspectExpressionResult",
			Handler:    _Stacks_InspectExpressionResult_Handler,
		},
		{
			MethodName: "OpenTerraformState",
			Handler:    _Stacks_OpenTerraformState_Handler,
		},
		{
			MethodName: "CloseTerraformState",
			Handler:    _Stacks_CloseTerraformState_Handler,
		},
		{
			MethodName: "ListResourceIdentities",
			Handler:    _Stacks_ListResourceIdentities_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenState",
			Handler:       _Stacks_OpenState_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "PlanStackChanges",
			Handler:       _Stacks_PlanStackChanges_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OpenPlan",
			Handler:       _Stacks_OpenPlan_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ApplyStackChanges",
			Handler:       _Stacks_ApplyStackChanges_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MigrateTerraformState",
			Handler:       _Stacks_MigrateTerraformState_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "stacks.proto",
}
