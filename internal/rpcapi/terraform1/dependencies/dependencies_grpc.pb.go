// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: dependencies.proto

package dependencies

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Dependencies_OpenSourceBundle_FullMethodName              = "/terraform1.dependencies.Dependencies/OpenSourceBundle"
	Dependencies_CloseSourceBundle_FullMethodName             = "/terraform1.dependencies.Dependencies/CloseSourceBundle"
	Dependencies_OpenDependencyLockFile_FullMethodName        = "/terraform1.dependencies.Dependencies/OpenDependencyLockFile"
	Dependencies_CreateDependencyLocks_FullMethodName         = "/terraform1.dependencies.Dependencies/CreateDependencyLocks"
	Dependencies_CloseDependencyLocks_FullMethodName          = "/terraform1.dependencies.Dependencies/CloseDependencyLocks"
	Dependencies_GetLockedProviderDependencies_FullMethodName = "/terraform1.dependencies.Dependencies/GetLockedProviderDependencies"
	Dependencies_BuildProviderPluginCache_FullMethodName      = "/terraform1.dependencies.Dependencies/BuildProviderPluginCache"
	Dependencies_OpenProviderPluginCache_FullMethodName       = "/terraform1.dependencies.Dependencies/OpenProviderPluginCache"
	Dependencies_CloseProviderPluginCache_FullMethodName      = "/terraform1.dependencies.Dependencies/CloseProviderPluginCache"
	Dependencies_GetCachedProviders_FullMethodName            = "/terraform1.dependencies.Dependencies/GetCachedProviders"
	Dependencies_GetBuiltInProviders_FullMethodName           = "/terraform1.dependencies.Dependencies/GetBuiltInProviders"
	Dependencies_GetProviderSchema_FullMethodName             = "/terraform1.dependencies.Dependencies/GetProviderSchema"
)

// DependenciesClient is the client API for Dependencies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DependenciesClient interface {
	// Opens a source bundle that was already extracted into the filesystem
	// somewhere, returning an opaque source bundle handle that can be used for
	// subsequent operations.
	OpenSourceBundle(ctx context.Context, in *OpenSourceBundle_Request, opts ...grpc.CallOption) (*OpenSourceBundle_Response, error)
	// Closes a previously-opened source bundle, invalidating the given handle
	// and therefore making it safe to delete or modify the bundle directory
	// on disk.
	CloseSourceBundle(ctx context.Context, in *CloseSourceBundle_Request, opts ...grpc.CallOption) (*CloseSourceBundle_Response, error)
	// Reads and parses an existing dependency lock file from the filesystem,
	// returning a dependency locks handle.
	//
	// This function parses a user-provided source file, and so invalid content
	// in that file is treated as diagnostics in a successful response rather
	// than as an RPC error. Callers must check whether the dependency locks
	// handle in the response is set (non-zero) before using it, and treat
	// an unset handle as indicating a user error which is described in the
	// accompanying diagnostics. Diagnostics can also be returned along with
	// a valid handle, e.g. if there are non-blocking warning diagnostics.
	OpenDependencyLockFile(ctx context.Context, in *OpenDependencyLockFile_Request, opts ...grpc.CallOption) (*OpenDependencyLockFile_Response, error)
	// Creates an in-memory-only dependency locks handle with a fixed set of
	// dependency selections provided as arguments.
	CreateDependencyLocks(ctx context.Context, in *CreateDependencyLocks_Request, opts ...grpc.CallOption) (*CreateDependencyLocks_Response, error)
	CloseDependencyLocks(ctx context.Context, in *CloseDependencyLocks_Request, opts ...grpc.CallOption) (*CloseDependencyLocks_Response, error)
	// Returns information about the provider version selections in a
	// dependency locks object.
	GetLockedProviderDependencies(ctx context.Context, in *GetLockedProviderDependencies_Request, opts ...grpc.CallOption) (*GetLockedProviderDependencies_Response, error)
	// Populates a new provider plugin cache directory in the local filesystem
	// based on the provider version selections in a given dependency locks
	// object.
	//
	// This particular RPC can only install already-selected provider packages
	// recorded in a dependency locks object; it does not support "upgrading"
	// provider selections to newer versions as a CLI user would do with
	// "terraform init -upgrade", because there would be no way to then
	// commit the updated locks to disk as a lock file.
	BuildProviderPluginCache(ctx context.Context, in *BuildProviderPluginCache_Request, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BuildProviderPluginCache_Event], error)
	// Opens an existing local filesystem directory as a provider plugin cache
	// directory, returning a plugin cache handle that can be used with other
	// RPC operations.
	OpenProviderPluginCache(ctx context.Context, in *OpenProviderPluginCache_Request, opts ...grpc.CallOption) (*OpenProviderPluginCache_Response, error)
	CloseProviderPluginCache(ctx context.Context, in *CloseProviderPluginCache_Request, opts ...grpc.CallOption) (*CloseProviderPluginCache_Response, error)
	// Returns information about the specific provider packages that are
	// available in the given provider plugin cache.
	GetCachedProviders(ctx context.Context, in *GetCachedProviders_Request, opts ...grpc.CallOption) (*GetCachedProviders_Response, error)
	// Returns information about the built-in providers that are compiled in
	// to this Terraform Core server.
	GetBuiltInProviders(ctx context.Context, in *GetBuiltInProviders_Request, opts ...grpc.CallOption) (*GetBuiltInProviders_Response, error)
	// Returns a description of the schema for a particular provider in a
	// given provider plugin cache, or of a particular built-in provider
	// known to this version of Terraform Core.
	//
	// WARNING: This operation requires executing the selected provider plugin,
	// which therefore allows it to run arbitrary code as a child process of
	// this Terraform Core server, with access to all of the same resources.
	// This should typically be used only with providers explicitly selected
	// in a dependency lock file, so users can control what external code
	// has the potential to run in a context that probably has access to
	// private source code and other sensitive information.
	GetProviderSchema(ctx context.Context, in *GetProviderSchema_Request, opts ...grpc.CallOption) (*GetProviderSchema_Response, error)
}

type dependenciesClient struct {
	cc grpc.ClientConnInterface
}

func NewDependenciesClient(cc grpc.ClientConnInterface) DependenciesClient {
	return &dependenciesClient{cc}
}

func (c *dependenciesClient) OpenSourceBundle(ctx context.Context, in *OpenSourceBundle_Request, opts ...grpc.CallOption) (*OpenSourceBundle_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenSourceBundle_Response)
	err := c.cc.Invoke(ctx, Dependencies_OpenSourceBundle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependenciesClient) CloseSourceBundle(ctx context.Context, in *CloseSourceBundle_Request, opts ...grpc.CallOption) (*CloseSourceBundle_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseSourceBundle_Response)
	err := c.cc.Invoke(ctx, Dependencies_CloseSourceBundle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependenciesClient) OpenDependencyLockFile(ctx context.Context, in *OpenDependencyLockFile_Request, opts ...grpc.CallOption) (*OpenDependencyLockFile_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenDependencyLockFile_Response)
	err := c.cc.Invoke(ctx, Dependencies_OpenDependencyLockFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependenciesClient) CreateDependencyLocks(ctx context.Context, in *CreateDependencyLocks_Request, opts ...grpc.CallOption) (*CreateDependencyLocks_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDependencyLocks_Response)
	err := c.cc.Invoke(ctx, Dependencies_CreateDependencyLocks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependenciesClient) CloseDependencyLocks(ctx context.Context, in *CloseDependencyLocks_Request, opts ...grpc.CallOption) (*CloseDependencyLocks_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseDependencyLocks_Response)
	err := c.cc.Invoke(ctx, Dependencies_CloseDependencyLocks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependenciesClient) GetLockedProviderDependencies(ctx context.Context, in *GetLockedProviderDependencies_Request, opts ...grpc.CallOption) (*GetLockedProviderDependencies_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLockedProviderDependencies_Response)
	err := c.cc.Invoke(ctx, Dependencies_GetLockedProviderDependencies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependenciesClient) BuildProviderPluginCache(ctx context.Context, in *BuildProviderPluginCache_Request, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BuildProviderPluginCache_Event], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Dependencies_ServiceDesc.Streams[0], Dependencies_BuildProviderPluginCache_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BuildProviderPluginCache_Request, BuildProviderPluginCache_Event]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Dependencies_BuildProviderPluginCacheClient = grpc.ServerStreamingClient[BuildProviderPluginCache_Event]

func (c *dependenciesClient) OpenProviderPluginCache(ctx context.Context, in *OpenProviderPluginCache_Request, opts ...grpc.CallOption) (*OpenProviderPluginCache_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenProviderPluginCache_Response)
	err := c.cc.Invoke(ctx, Dependencies_OpenProviderPluginCache_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependenciesClient) CloseProviderPluginCache(ctx context.Context, in *CloseProviderPluginCache_Request, opts ...grpc.CallOption) (*CloseProviderPluginCache_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseProviderPluginCache_Response)
	err := c.cc.Invoke(ctx, Dependencies_CloseProviderPluginCache_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependenciesClient) GetCachedProviders(ctx context.Context, in *GetCachedProviders_Request, opts ...grpc.CallOption) (*GetCachedProviders_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCachedProviders_Response)
	err := c.cc.Invoke(ctx, Dependencies_GetCachedProviders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependenciesClient) GetBuiltInProviders(ctx context.Context, in *GetBuiltInProviders_Request, opts ...grpc.CallOption) (*GetBuiltInProviders_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBuiltInProviders_Response)
	err := c.cc.Invoke(ctx, Dependencies_GetBuiltInProviders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependenciesClient) GetProviderSchema(ctx context.Context, in *GetProviderSchema_Request, opts ...grpc.CallOption) (*GetProviderSchema_Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProviderSchema_Response)
	err := c.cc.Invoke(ctx, Dependencies_GetProviderSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DependenciesServer is the server API for Dependencies service.
// All implementations must embed UnimplementedDependenciesServer
// for forward compatibility.
type DependenciesServer interface {
	// Opens a source bundle that was already extracted into the filesystem
	// somewhere, returning an opaque source bundle handle that can be used for
	// subsequent operations.
	OpenSourceBundle(context.Context, *OpenSourceBundle_Request) (*OpenSourceBundle_Response, error)
	// Closes a previously-opened source bundle, invalidating the given handle
	// and therefore making it safe to delete or modify the bundle directory
	// on disk.
	CloseSourceBundle(context.Context, *CloseSourceBundle_Request) (*CloseSourceBundle_Response, error)
	// Reads and parses an existing dependency lock file from the filesystem,
	// returning a dependency locks handle.
	//
	// This function parses a user-provided source file, and so invalid content
	// in that file is treated as diagnostics in a successful response rather
	// than as an RPC error. Callers must check whether the dependency locks
	// handle in the response is set (non-zero) before using it, and treat
	// an unset handle as indicating a user error which is described in the
	// accompanying diagnostics. Diagnostics can also be returned along with
	// a valid handle, e.g. if there are non-blocking warning diagnostics.
	OpenDependencyLockFile(context.Context, *OpenDependencyLockFile_Request) (*OpenDependencyLockFile_Response, error)
	// Creates an in-memory-only dependency locks handle with a fixed set of
	// dependency selections provided as arguments.
	CreateDependencyLocks(context.Context, *CreateDependencyLocks_Request) (*CreateDependencyLocks_Response, error)
	CloseDependencyLocks(context.Context, *CloseDependencyLocks_Request) (*CloseDependencyLocks_Response, error)
	// Returns information about the provider version selections in a
	// dependency locks object.
	GetLockedProviderDependencies(context.Context, *GetLockedProviderDependencies_Request) (*GetLockedProviderDependencies_Response, error)
	// Populates a new provider plugin cache directory in the local filesystem
	// based on the provider version selections in a given dependency locks
	// object.
	//
	// This particular RPC can only install already-selected provider packages
	// recorded in a dependency locks object; it does not support "upgrading"
	// provider selections to newer versions as a CLI user would do with
	// "terraform init -upgrade", because there would be no way to then
	// commit the updated locks to disk as a lock file.
	BuildProviderPluginCache(*BuildProviderPluginCache_Request, grpc.ServerStreamingServer[BuildProviderPluginCache_Event]) error
	// Opens an existing local filesystem directory as a provider plugin cache
	// directory, returning a plugin cache handle that can be used with other
	// RPC operations.
	OpenProviderPluginCache(context.Context, *OpenProviderPluginCache_Request) (*OpenProviderPluginCache_Response, error)
	CloseProviderPluginCache(context.Context, *CloseProviderPluginCache_Request) (*CloseProviderPluginCache_Response, error)
	// Returns information about the specific provider packages that are
	// available in the given provider plugin cache.
	GetCachedProviders(context.Context, *GetCachedProviders_Request) (*GetCachedProviders_Response, error)
	// Returns information about the built-in providers that are compiled in
	// to this Terraform Core server.
	GetBuiltInProviders(context.Context, *GetBuiltInProviders_Request) (*GetBuiltInProviders_Response, error)
	// Returns a description of the schema for a particular provider in a
	// given provider plugin cache, or of a particular built-in provider
	// known to this version of Terraform Core.
	//
	// WARNING: This operation requires executing the selected provider plugin,
	// which therefore allows it to run arbitrary code as a child process of
	// this Terraform Core server, with access to all of the same resources.
	// This should typically be used only with providers explicitly selected
	// in a dependency lock file, so users can control what external code
	// has the potential to run in a context that probably has access to
	// private source code and other sensitive information.
	GetProviderSchema(context.Context, *GetProviderSchema_Request) (*GetProviderSchema_Response, error)
	mustEmbedUnimplementedDependenciesServer()
}

// UnimplementedDependenciesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDependenciesServer struct{}

func (UnimplementedDependenciesServer) OpenSourceBundle(context.Context, *OpenSourceBundle_Request) (*OpenSourceBundle_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenSourceBundle not implemented")
}
func (UnimplementedDependenciesServer) CloseSourceBundle(context.Context, *CloseSourceBundle_Request) (*CloseSourceBundle_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseSourceBundle not implemented")
}
func (UnimplementedDependenciesServer) OpenDependencyLockFile(context.Context, *OpenDependencyLockFile_Request) (*OpenDependencyLockFile_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenDependencyLockFile not implemented")
}
func (UnimplementedDependenciesServer) CreateDependencyLocks(context.Context, *CreateDependencyLocks_Request) (*CreateDependencyLocks_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDependencyLocks not implemented")
}
func (UnimplementedDependenciesServer) CloseDependencyLocks(context.Context, *CloseDependencyLocks_Request) (*CloseDependencyLocks_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseDependencyLocks not implemented")
}
func (UnimplementedDependenciesServer) GetLockedProviderDependencies(context.Context, *GetLockedProviderDependencies_Request) (*GetLockedProviderDependencies_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLockedProviderDependencies not implemented")
}
func (UnimplementedDependenciesServer) BuildProviderPluginCache(*BuildProviderPluginCache_Request, grpc.ServerStreamingServer[BuildProviderPluginCache_Event]) error {
	return status.Errorf(codes.Unimplemented, "method BuildProviderPluginCache not implemented")
}
func (UnimplementedDependenciesServer) OpenProviderPluginCache(context.Context, *OpenProviderPluginCache_Request) (*OpenProviderPluginCache_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenProviderPluginCache not implemented")
}
func (UnimplementedDependenciesServer) CloseProviderPluginCache(context.Context, *CloseProviderPluginCache_Request) (*CloseProviderPluginCache_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseProviderPluginCache not implemented")
}
func (UnimplementedDependenciesServer) GetCachedProviders(context.Context, *GetCachedProviders_Request) (*GetCachedProviders_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCachedProviders not implemented")
}
func (UnimplementedDependenciesServer) GetBuiltInProviders(context.Context, *GetBuiltInProviders_Request) (*GetBuiltInProviders_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBuiltInProviders not implemented")
}
func (UnimplementedDependenciesServer) GetProviderSchema(context.Context, *GetProviderSchema_Request) (*GetProviderSchema_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProviderSchema not implemented")
}
func (UnimplementedDependenciesServer) mustEmbedUnimplementedDependenciesServer() {}
func (UnimplementedDependenciesServer) testEmbeddedByValue()                      {}

// UnsafeDependenciesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DependenciesServer will
// result in compilation errors.
type UnsafeDependenciesServer interface {
	mustEmbedUnimplementedDependenciesServer()
}

func RegisterDependenciesServer(s grpc.ServiceRegistrar, srv DependenciesServer) {
	// If the following call pancis, it indicates UnimplementedDependenciesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Dependencies_ServiceDesc, srv)
}

func _Dependencies_OpenSourceBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenSourceBundle_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependenciesServer).OpenSourceBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dependencies_OpenSourceBundle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependenciesServer).OpenSourceBundle(ctx, req.(*OpenSourceBundle_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dependencies_CloseSourceBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseSourceBundle_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependenciesServer).CloseSourceBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dependencies_CloseSourceBundle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependenciesServer).CloseSourceBundle(ctx, req.(*CloseSourceBundle_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dependencies_OpenDependencyLockFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenDependencyLockFile_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependenciesServer).OpenDependencyLockFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dependencies_OpenDependencyLockFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependenciesServer).OpenDependencyLockFile(ctx, req.(*OpenDependencyLockFile_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dependencies_CreateDependencyLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDependencyLocks_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependenciesServer).CreateDependencyLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dependencies_CreateDependencyLocks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependenciesServer).CreateDependencyLocks(ctx, req.(*CreateDependencyLocks_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dependencies_CloseDependencyLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseDependencyLocks_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependenciesServer).CloseDependencyLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dependencies_CloseDependencyLocks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependenciesServer).CloseDependencyLocks(ctx, req.(*CloseDependencyLocks_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dependencies_GetLockedProviderDependencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLockedProviderDependencies_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependenciesServer).GetLockedProviderDependencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dependencies_GetLockedProviderDependencies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependenciesServer).GetLockedProviderDependencies(ctx, req.(*GetLockedProviderDependencies_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dependencies_BuildProviderPluginCache_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BuildProviderPluginCache_Request)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DependenciesServer).BuildProviderPluginCache(m, &grpc.GenericServerStream[BuildProviderPluginCache_Request, BuildProviderPluginCache_Event]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Dependencies_BuildProviderPluginCacheServer = grpc.ServerStreamingServer[BuildProviderPluginCache_Event]

func _Dependencies_OpenProviderPluginCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenProviderPluginCache_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependenciesServer).OpenProviderPluginCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dependencies_OpenProviderPluginCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependenciesServer).OpenProviderPluginCache(ctx, req.(*OpenProviderPluginCache_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dependencies_CloseProviderPluginCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseProviderPluginCache_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependenciesServer).CloseProviderPluginCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dependencies_CloseProviderPluginCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependenciesServer).CloseProviderPluginCache(ctx, req.(*CloseProviderPluginCache_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dependencies_GetCachedProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCachedProviders_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependenciesServer).GetCachedProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dependencies_GetCachedProviders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependenciesServer).GetCachedProviders(ctx, req.(*GetCachedProviders_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dependencies_GetBuiltInProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBuiltInProviders_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependenciesServer).GetBuiltInProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dependencies_GetBuiltInProviders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependenciesServer).GetBuiltInProviders(ctx, req.(*GetBuiltInProviders_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dependencies_GetProviderSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProviderSchema_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependenciesServer).GetProviderSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dependencies_GetProviderSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependenciesServer).GetProviderSchema(ctx, req.(*GetProviderSchema_Request))
	}
	return interceptor(ctx, in, info, handler)
}

// Dependencies_ServiceDesc is the grpc.ServiceDesc for Dependencies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Dependencies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "terraform1.dependencies.Dependencies",
	HandlerType: (*DependenciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OpenSourceBundle",
			Handler:    _Dependencies_OpenSourceBundle_Handler,
		},
		{
			MethodName: "CloseSourceBundle",
			Handler:    _Dependencies_CloseSourceBundle_Handler,
		},
		{
			MethodName: "OpenDependencyLockFile",
			Handler:    _Dependencies_OpenDependencyLockFile_Handler,
		},
		{
			MethodName: "CreateDependencyLocks",
			Handler:    _Dependencies_CreateDependencyLocks_Handler,
		},
		{
			MethodName: "CloseDependencyLocks",
			Handler:    _Dependencies_CloseDependencyLocks_Handler,
		},
		{
			MethodName: "GetLockedProviderDependencies",
			Handler:    _Dependencies_GetLockedProviderDependencies_Handler,
		},
		{
			MethodName: "OpenProviderPluginCache",
			Handler:    _Dependencies_OpenProviderPluginCache_Handler,
		},
		{
			MethodName: "CloseProviderPluginCache",
			Handler:    _Dependencies_CloseProviderPluginCache_Handler,
		},
		{
			MethodName: "GetCachedProviders",
			Handler:    _Dependencies_GetCachedProviders_Handler,
		},
		{
			MethodName: "GetBuiltInProviders",
			Handler:    _Dependencies_GetBuiltInProviders_Handler,
		},
		{
			MethodName: "GetProviderSchema",
			Handler:    _Dependencies_GetProviderSchema_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BuildProviderPluginCache",
			Handler:       _Dependencies_BuildProviderPluginCache_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dependencies.proto",
}
