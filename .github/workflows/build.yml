name: Build Terraform CLI Packages

# If you want to test changes to this file before merging to a main branch,
# push them up to a branch whose name has the prefix "build-workflow-dev/",
# which is a special prefix that triggers this workflow even though it's not
# actually a release branch.

# NOTE: This workflow is currently used only to verify that all commits to a
# release branch are buildable. It's set up to generate some artifacts that
# might in principle be consumed by a downstream release process, but currently
# they are not used in this way and official Terraform CLI releases are instead
# built using a separate process maintained elsewhere. We intend to adopt this
# new process fully later, once other HashiCorp-internal tooling is ready.
#
# Currently this process produces what should be working packages but packages
# NOT suitable for distribution to end-users as official releases, because it
# doesn't include a step to ensure that "terraform version" (and similar) will
# report the intended version number. Consequently we can safely use these
# results for testing purposes, but not yet for release purposes. See the
# "build" job below for a FIXME comment related to version numbers.

on:
  workflow_dispatch:
  push:
    branches:
      - main
      - 'v[0-9]+.[0-9]+'
      - build-workflow-dev/*
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+*'

env:
  PKG_NAME: "terraform"

permissions:
  contents: read
  statuses: write

jobs:
  get-product-version:
    name: "Determine intended Terraform version"
    runs-on: ubuntu-latest
    outputs:
      product-version: ${{ steps.get-product-version.outputs.product-version }}
      product-version-base: ${{ steps.get-product-version.outputs.product-version-base }}
      product-version-pre: ${{ steps.get-product-version.outputs.product-version-pre }}
      experiments: ${{ steps.get-product-version.outputs.experiments }}
      go-ldflags: ${{ steps.get-product-version.outputs.go-ldflags }}

    steps:
      - uses: actions/checkout@v3
      - name: Git Describe
        id: git-describe
        run: |
          # The actions/checkout action tries hard to fetch as little as
          # possible, to the extent that even with "depth: 0" it fails to
          # produce enough tag metadata for us to "describe" successfully.
          # We'll therefore re-fetch the tags here to make sure we will
          # select the most accurate version number.
          git fetch origin --force --tags --quiet --unshallow
          git log --tags --simplify-by-decoration --decorate-refs='refs/tags/v*' --pretty=format:'%h %<|(35)%S %ci' --max-count 15 --topo-order
          set -e
          RAW_VERSION=$(git describe --tags --match='v*' ${GITHUB_SHA})
          echo "
          
          Raw version is ${RAW_VERSION}"
          echo "::set-output name=raw-version::${RAW_VERSION}"
      - name: Decide version number
        id: get-product-version
        shell: bash
        env:
          RAW_VERSION: ${{ steps.git-describe.outputs.raw-version }}
        run: |
          # Trim the "v" prefix, if any.
          VERSION="${RAW_VERSION#v}"

          # Split off the build metadata part, if any
          # (we won't actually include it in our final version, and handle it only for
          # compleness against semver syntax.)
          IFS='+' read -ra VERSION BUILD_META <<< "$VERSION"

          # Separate out the prerelease part, if any
          # (version.go expects it to be in a separate variable)
          IFS='-' read -r BASE_VERSION PRERELEASE <<< "$VERSION"

          EXPERIMENTS_ENABLED=0
          if [[ "$PRERELEASE" == alpha* ]]; then
            EXPERIMENTS_ENABLED=1
          fi
          if [[ "$PRERELEASE" == dev* ]]; then
            EXPERIMENTS_ENABLED=1
          fi

          LDFLAGS="-w -s"
          if [[ "$EXPERIMENTS_ENABLED" == 1 ]]; then
            LDFLAGS="${LDFLAGS} -X 'main.experimentsAllowed=yes'"
          fi
          LDFLAGS="${LDFLAGS} -X 'github.com/hashicorp/terraform/version.Version=${BASE_VERSION}'"
          LDFLAGS="${LDFLAGS} -X 'github.com/hashicorp/terraform/version.Prerelease=${PRERELEASE}'"

          echo "Building Terraform CLI ${VERSION}"
          if [[ "$EXPERIMENTS_ENABLED" == 1 ]]; then
            echo "This build allows use of experimental features"
          fi
          echo "::set-output name=product-version::${VERSION}"
          echo "::set-output name=product-version-base::${BASE_VERSION}"
          echo "::set-output name=product-version-pre::${PRERELEASE}"
          echo "::set-output name=experiments::${EXPERIMENTS_ENABLED}"
          echo "::set-output name=go-ldflags::${LDFLAGS}"
      - name: Report chosen version number
        run: |
          [ -n "${{steps.get-product-version.outputs.product-version}}" ]
          echo "::notice title=Terraform CLI Version::${{ steps.get-product-version.outputs.product-version }}"

  get-go-version:
    name: "Determine Go toolchain version"
    runs-on: ubuntu-latest
    outputs:
      go-version: ${{ steps.get-go-version.outputs.version }}

    steps:
      - uses: actions/checkout@v2
      - name: Determine Go version
        id: get-go-version
        uses: ./.github/actions/go-version

  generate-metadata-file:
    name: "Generate release metadata"
    runs-on: ubuntu-latest
    needs: get-product-version
    outputs:
      filepath: ${{ steps.generate-metadata-file.outputs.filepath }}

    steps:
      - uses: actions/checkout@v2
      - name: Generate package metadata
        id: generate-metadata-file
        uses: hashicorp/actions-generate-metadata@v1
        with:
          version: ${{ needs.get-product-version.outputs.product-version }}
          product: ${{ env.PKG_NAME }}

      - uses: actions/upload-artifact@v2
        with:
          name: metadata.json
          path: ${{ steps.generate-metadata-file.outputs.filepath }}

  build:
    name: Build for ${{ matrix.goos }}_${{ matrix.goarch }}
    runs-on: ${{ matrix.runson }}
    needs:
      - get-product-version
      - get-go-version
    strategy:
      matrix:
        include:
          - {goos: "freebsd", goarch: "386", runson: "ubuntu-latest"}
          - {goos: "freebsd", goarch: "amd64", runson: "ubuntu-latest"}
          - {goos: "freebsd", goarch: "arm", runson: "ubuntu-latest"}
          - {goos: "linux", goarch: "386", runson: "ubuntu-latest"}
          - {goos: "linux", goarch: "amd64", runson: "ubuntu-latest"}
          - {goos: "linux", goarch: "arm", runson: "ubuntu-latest"}
          - {goos: "linux", goarch: "arm64", runson: "ubuntu-latest"}
          - {goos: "openbsd", goarch: "386", runson: "ubuntu-latest"}
          - {goos: "openbsd", goarch: "amd64", runson: "ubuntu-latest"}
          - {goos: "solaris", goarch: "amd64", runson: "ubuntu-latest"}
          - {goos: "windows", goarch: "386", runson: "ubuntu-latest"}
          - {goos: "windows", goarch: "amd64", runson: "ubuntu-latest"}
          - {goos: "darwin", goarch: "amd64", runson: "ubuntu-latest"}
          - {goos: "darwin", goarch: "arm64", runson: "ubuntu-latest"}
      fail-fast: false

    env:
      FULL_VERSION: ${{ needs.get-product-version.outputs.product-version }}
      BASE_VERSION: ${{ needs.get-product-version.outputs.product-version-base }}
      VERSION_PRERELEASE: ${{ needs.get-product-version.outputs.product-version-pre }}
      EXPERIMENTS_ENABLED: ${{ needs.get-product-version.outputs.experiments }}
      GO_LDFLAGS: ${{ needs.get-product-version.outputs.go-ldflags }}

    steps:
      - uses: actions/checkout@v2

      - name: Install Go toolchain
        uses: actions/setup-go@v2
        with:
          go-version: ${{ needs.get-go-version.outputs.go-version }}

      # FIXME: We're not currently setting the hard-coded version string in
      # version/version.go at any point here, which means that the packages
      # this process builds are not suitable for release. Once we're using
      # Go 1.18 we may begin using the version information automatically
      # embedded by the Go toolchain, at which point we won't need any
      # special steps during build, but failing that we'll need to rework
      # the version/version.go package so we can more readily update it
      # using linker flags rather than direct code modification.

      - name: Build
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          ACTIONSOS: ${{ matrix.runson }}
        run: |
          mkdir dist out
          if [ "$ACTIONSOS" == "macos-latest" ] && [ "$GOOS" == "darwin" ]; then
            # When building for macOS _on_ macOS we must force CGo to get
            # correct hostname resolution behavior. (This must be conditional
            # because other cross-compiles won't have suitable headers
            # available to use CGo; darwin_amd64 has suitable headers to
            # cross-build for darwin_arm64.)
            export CGO_ENABLED=1
          fi
          set -x
          go build -ldflags "${GO_LDFLAGS}" -o dist/ .
          zip -r -j out/${{ env.PKG_NAME }}_${FULL_VERSION}_${{ matrix.goos }}_${{ matrix.goarch }}.zip dist/

      - uses: actions/upload-artifact@v2
        with:
          name: ${{ env.PKG_NAME }}_${{ env.FULL_VERSION }}_${{ matrix.goos }}_${{ matrix.goarch }}.zip
          path: out/${{ env.PKG_NAME }}_${{ env.FULL_VERSION }}_${{ matrix.goos }}_${{ matrix.goarch }}.zip

#  package-linux:
#    name: "Build Linux distro packages for ${{ matrix.arch }}"
#    runs-on: ubuntu-latest
#    needs:
#      - get-product-version
#      - build
#    strategy:
#      matrix:
#        include:
#          - {arch: "386"}
#          - {arch: "amd64"}
#          - {arch: "arm"}
#          - {arch: "arm64"}
#      fail-fast: false
#
#    env:
#      os: linux
#      arch: ${{matrix.arch}}
#      version: ${{needs.get-product-version.outputs.product-version}}
#
#    steps:
#      - name: "Download Terraform CLI package"
#        uses: actions/download-artifact@v2
#        id: clipkg
#        with:
#          name: terraform_${{ env.version }}_${{ env.os }}_${{ env.arch }}.zip
#          path: .
#      - name: Extract packages
#        run: |
#          mkdir -p dist
#          (cd dist && unzip "../terraform_${{ env.version }}_${{ env.os }}_${{ env.arch }}.zip")
#          mkdir -p out
#      - name: Build Linux distribution packages
#        uses: hashicorp/actions-packaging-linux@v1
#        with:
#          name: "terraform"
#          description: "Terraform enables you to safely and predictably create, change, and improve infrastructure. It is an open source tool that codifies APIs into declarative configuration files that can be shared amongst team members, treated as code, edited, reviewed, and versioned."
#          arch: ${{ matrix.arch }}
#          version: ${{ env.version }}
#          maintainer: "HashiCorp"
#          homepage: "https://terraform.io/"
#          license: "MPL-2.0"
#          binary: "dist/terraform"
#          deb_depends: "git"
#          rpm_depends: "git"
#      - name: Gather Linux distribution package filenames
#        run: |
#          echo "RPM_PACKAGE=$(basename out/*.rpm)" >> $GITHUB_ENV
#          echo "DEB_PACKAGE=$(basename out/*.deb)" >> $GITHUB_ENV
#      - name: "Save .rpm package"
#        uses: actions/upload-artifact@v2
#        with:
#          name: ${{ env.RPM_PACKAGE }}
#          path: out/${{ env.RPM_PACKAGE }}
#      - name: "Save .deb package"
#        uses: actions/upload-artifact@v2
#        with:
#          name: ${{ env.DEB_PACKAGE }}
#          path: out/${{ env.DEB_PACKAGE }}


